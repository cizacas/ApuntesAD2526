   UNIDAD 3-parte 3



ACCESO A BASES DE DATOS
 ORIENTADAS A OBJETOS
5.- Lenguaje de consulta JPQL
Con la implementación de JPA se incluye el lenguaje de consultas JPQL
basado en el lenguaje SQL.
Las consultas JPQL se pueden procesar con objetos Query o con objetos
TypedQuery. Esos objetos se instancian a partir de un EntityManager.
Suponiendo que em es un EntityManager, para instanciar un Query o un
TypedQuery para consultar todos los objetos Empleado almacenados,
haríamos:
Query q1 = em.createQuery("SELECT e FROM Empleado e");


TypedQuery<Country> q2 = em.createQuery("SELECT e FROM
Empleado e", Empleado.class);
5.1- Lenguaje de consulta JPQL. NamedQuery
En una Entity Class podemos incluir consultas nombradas.
Están declaradas en la clase Entity mediante anotación @NamedQuery. Por
ejemplo, para la clase Empleado:




La primera NamedQuery sirve para consultar todos del empleados y la
segunda es una consulta parametrizada o dinámica y consultaría todos los
empleados del departamento cuyo id sea igual al valor que contenga el
parámetro num.
5.2.- Lenguaje de consulta JPQL. Ejecución de consultas
Ejecución de consultas.
Normalmente, tanto Query como TypedQuery, son lanzadas a ejecución para
devolver los resultados mediante los métodos:


List<T> listAllResults()
Devuelve una lista de objetos T con el resultado de la consulta.


Object getSingleResult()
Se usa para procesar consultas que devuelven un único resultado. El resultado
se devuelve en Object, que habrá que castearlo a la clase adecuada.
Este método `puede lanzar las excepciones NoResultException (cuando no hay
resultados a devolver) y. NonUniqueResultException (cuando se debería
devolver más de un resultado).
5.2.- Lenguaje de consulta JPQL. Ejecución de consultas
Ejemplo de ejecución y uso de una Query que devuelve una lista de objetos:




Ejemplo de ejecución y uso de una TypedQuery que devuelve una lista de
objetos:




Ejemplo de ejecución y uso de una Query que devuelve un objeto:
5.2.- Lenguaje de consulta JPQL. Ejecución de consultas
Ejemplo de ejecución de una NamedQuery. En este caso se instancia el
objeto Query o el TypedQuery con el método createNamedQuery:




Ejemplo de ejecución de la NamedQuery parametrizada
5.3.- Lenguaje de consulta JPQL. Consultas parametrizadas
Las consultas parametrizadas o dinámicas se construyen incluyendo en el
texto de la consulta parámetros con un nombre. A estos parámetros se le
asignan valores con el método setParameter en tiempo de ejecución y antes
de ser ejecutadas esas consultas.
Dentro del texto de la consulta los parámetros se nombran con una palabra
precedida del carácter dos puntos. Por ejemplo:
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Al igual que en lenguaje SQL, en JPQL se pueden usar dentro de una
instrucción cláusulas:
DISTINCT
WHERE
      incluyendo operadores relacionales, lógicos, IN, LIKE, BETWEEN
ORDER BY
GROUP BY
HAVING
También se pueden establecer en las consultas relaciones entre objetos
mediante:
      JOIN
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT


 Ejemplos de consultas con filtro WHERE:
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Ejemplos de consultas con filtro DISTINCT (sin datos repetidos) y con ORDER
BY.
Es un ejemplo en lo que se consulta son edades de empleados. Aquí vemos
por primera vez como se pueden obtener en la consulta datos que forman
parte de los objetos persistentes, en este caso la edad.




También se podría usar GROUP BY:
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Proyección de resultados:
Es posible recuperar un conjunto de atributos de las instancias, sin que
formen una entidad. Esto es útil cuando además de consultar algún atributo
de cada instancia, necesitamos obtener otros valores.
Vemos primero un ejemplo en el que se puede usar la proyección aunque no
sería recomendable. Este caso sólo sería aceptable si cada instancia tiene
muchos atributos y se desea consultar unos pocos.




En estos casos, siempre el List que se devuelve es un array de objetos Object
(que tendrá tantos elementos como datos se consulten).
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Proyección de resultados:
Este ejemplo ya tendría más sentido ya que trata de obtener cuantos
empleados hay de cada edad (la edad forma parte de cada instancia pero no
el número de empleados).
Hay que usar un agrupamiento GROUP BY y una función de agrupamiento.
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Uso de HAVING:
A partir del ejemplo anterior, podemos ver que se puede usar la cláusula
HAVING para filtrar resultados por una condición basada en una función de
agrupamiento.
Obtenemos las edades en las que hay más de 5 empleados.
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Relaciones entre entidades:
Supongamos que entre Departamento y Empleado no hay establecidas las relaciones
OneToMany y ManyToOne. Únicamente, se tiene en Empleado un atributo entero
numDept que indica el número de departamento al que pertenece cada empleado. En
el siguiente ejemplo, se listarían nombre de empleados y nombres de departamento al
que pertenecen.
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Relaciones JOIN entre entidades:
Se puede usar JOIN entre objetos de una entidad y objetos de una colección de la
misma entidad para usar la relación que existe entre ellos. Se puede usar JOIN o sus
variantes INNER JOIN, LEFT JOIN, OUTER JOIN.

Normalmente se usa para relacionar objetos de una entidad con una colección
mapeada con relación OneToMany o una ManyToMany. Por ejemplo, si Empleado se
relaciona con Proyecto con relación ManyToMany para representar que en un proyecto
hay varios empleados y que un empleado puede participar en varios proyectos, la
siguiente consulta obtiene los empleados que participan en un determinado proyecto;
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT


Valores nulos y colecciones vacías.
Se pueden filtrar valores nulos con las cláusulas NULL y NOT NULL. Por ejemplo, para
obtener los nombres de empleados que no tienen asignado departamento, haríamos:
5.4.- Lenguaje de consulta JPQL. Cláusulas SELECT
Funciones:
JPQL permite usar varias funciones similares a funciones SQL en las consultas .

        – CONCAT
        – LOWER
        – UPPER
        – LENGTH
        – TRIM
        – LOCATE
        – MAX
        – COUNT
        – SUM
        – AVG
5.5.- Consultas JPQL de actualización


Se puede ejecutar consultas de actualización UPDATE y DELETE. Estas consultas siempre
deben ejecutarse dentro de una transacción activa. Lo vemos con dos ejemplos:

Eliminar todos los empleados que no tengan asignado departamento.




Incrementar en 1 la edad de todos los empleados con id superior a 7.
5.6.- La API Criteria

La API Criteria de JPA permite realizar consultas dinámicas en tiempo de
ejecución mediante el uso de métodos para filtrar, ordenar,etc.
NO requiere escribir y usar una consulta JPQL.

Se parte de una selección de todas las instancias de una entidad para después ir
filtrando mediante métodos esas instancias.

Para realizar con Criteria una consulta de todos los empleados, resultaría complejo ya
que tendríamos que hacer:
5.6.- La API Criteria


CriteriaBuilder: Es una clase Factory de CriteriaQuery. Se puede usar el mismo
CriteriaBuilder para instanciar varios CriteriaQuery.
CriteriaQuery: Permite representar el tipo de resultado de la consulta que se
va a crear y usar. En el caso anterior una consulta para devolver objetos
Empleado. A un CriteriaQuery se le podrán aplicar después varios
modificadores.
CriteriaQuery.from: Aquí indicamos que entidad estamos consultando.
También podríamos usar relaciones JOIN y subconsultas.
CriteriaQuery.select: Para especificar los objetos o campos de objeto que
queremos devolver.
CriteriaQuery.where: Para establecer las condiciones de filtrado de la
consulta.
5.6.- La API Criteria

Ejemplo de obtención de datos de empleados de más de 25 años.




Ejemplo de obtención de datos de empleados del departamento 7.
5.6.- La API Criteria

Ejemplo de obtención de datos de empleados del departamento cuyo id sea
igual al que se haya establecido en la consulta como parámetro.
5.6.- La API Criteria

Ejemplo de obtención de datos de empleados de más de 25 años del
departamento 7.




Ejemplo de obtención de datos de empleados de más de 25 años ordenados
por edad descendentemente.
